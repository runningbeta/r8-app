pragma solidity ^0.4.23;

import "openzeppelin-solidity/contracts/AddressUtils.sol";


contract DelegateProxy {
  using AddressUtils for address;

  uint256 constant public FWD_GAS_LIMIT = 10000;

  /**
   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)
   * @param _dst Destination address to perform the delegatecall
   * @param _calldata Calldata for the delegatecall
   */
  function delegatedFwd(address _dst, bytes _calldata) internal {
    delegatedFwd(_dst, _calldata, 0);
  }

  /**
   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)
   * @param _dst Destination address to perform the delegatecall
   * @param _calldata Calldata for the delegatecall
   * @param _minReturnSize Minimum size the call needs to return, if less than that it will revert
   */
  function delegatedFwd(address _dst, bytes _calldata, uint256 _minReturnSize) internal {
    require(_dst.isContract());
    uint256 size;
    uint256 result;
    uint256 fwd_gas_limit = FWD_GAS_LIMIT;

    assembly {
      result := delegatecall(sub(gas, fwd_gas_limit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)
      size := returndatasize
    }

    require(size >= _minReturnSize);

    assembly {
      let ptr := mload(0x40)
      returndatacopy(ptr, 0, size)

      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.
      // if the call returned error data, forward it
      switch result case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }

}
